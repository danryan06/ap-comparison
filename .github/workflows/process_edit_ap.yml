name: Process Edit AP Submissions

on:
  issues:
    types: [opened, edited]

permissions:
  contents: write
  pull-requests: write
  issues: read

jobs:
  edit-ap-from-issue:
    runs-on: ubuntu-latest
    if: >
      github.event.issue.state == 'open' &&
      startsWith(github.event.issue.title, 'Edit AP:')

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Extract JSON from issue body, download image, and update ap_data.json
        id: update-json
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const github = require('@actions/github');
            const fs = require('fs');
            const path = require('path');
            const https = require('https');
            const http = require('http');

            const issue = github.context.payload.issue;
            const body = issue.body || '';

            // Find the ```json ... ``` block containing the updated AP entry
            let match = body.match(/```json\s*([\s\S]*?)```/);
            if (!match) {
              // Fallback: try any JSON-looking block
              match = body.match(/\{\s*[\s\S]*\}/);
            }

            if (!match) {
              core.setFailed('No JSON snippet found in issue body. Make sure the JSON snippet field is filled.');
              return;
            }

            const jsonText = match[1] ? match[1].trim() : match[0].trim();
            core.info('Found updated AP JSON snippet:');
            core.info(jsonText);

            let ap;
            try {
              ap = JSON.parse(jsonText);
            } catch (err) {
              core.setFailed('Invalid JSON in issue: ' + err.message);
              return;
            }

            // Basic sanity checks
            if (!ap.vendor || !ap.model) {
              core.setFailed('JSON must include at least "vendor" and "model" fields.');
              return;
            }

            // Helper to slugify vendor/model for filenames
            function slugify(s) {
              return String(s || '')
                .toLowerCase()
                .trim()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
            }

            // Helper to normalize "Vendor Model" strings
            function normalizeLabel(s) {
              return String(s || '')
                .toLowerCase()
                .trim()
                .replace(/\s+/g, ' ');
            }

            // Try to extract the "Requested edit for: Vendor Model" line
            const requestedMatch = body.match(/^Requested edit for:\s*(.+)$/m);
            const requestedLabelRaw = requestedMatch ? requestedMatch[1].trim() : '';
            const requestedLabel = normalizeLabel(requestedLabelRaw);

            // Try to find an image URL from JSON or issue body
            function findImageUrlFromBody(text) {
              if (!text) return null;
              // Match common image hosts and extensions OR GitHub user-images URLs
              const imgRegex = /(https?:\/\/[^\s)]+?(?:\.(?:png|jpe?g|gif|webp)|user-images\.githubusercontent\.com\/[^\s)]+))/i;
              const m = text.match(imgRegex);
              return m ? m[1] : null;
            }

            async function downloadImageIfNeeded(ap, bodyText) {
              let url = ap.image_url && String(ap.image_url).trim();
              if (!url) {
                url = findImageUrlFromBody(bodyText);
              }
              if (!url) {
                core.info('No image URL found in JSON or issue body; skipping image download.');
                return ap;
              }

              core.info(`Attempting to download image from ${url}`);

              const imagesDir = path.join(process.env.GITHUB_WORKSPACE, 'images');
              fs.mkdirSync(imagesDir, { recursive: true });

              const vendorSlug = slugify(ap.vendor);
              const modelSlug = slugify(ap.model);

              const extMatch = url.match(/\.(png|jpe?g|gif|webp)(?:\?|#|$)/i);
              const ext = extMatch ? `.${extMatch[1].toLowerCase().replace('jpeg','jpg')}` : '.jpg';
              const filename = `${vendorSlug}-${modelSlug}${ext}`;
              const destPath = path.join(imagesDir, filename);

              const client = url.startsWith('https:') ? https : http;

              await new Promise((resolve, reject) => {
                const file = fs.createWriteStream(destPath);
                const request = client.get(url, response => {
                  if (response.statusCode && response.statusCode >= 400) {
                    file.close();
                    fs.unlink(destPath, () => {});
                    return reject(new Error(`Image download failed with status ${response.statusCode}`));
                  }
                  response.pipe(file);
                  file.on('finish', () => {
                    file.close();
                    resolve(null);
                  });
                });
                request.on('error', err => {
                  file.close();
                  fs.unlink(destPath, () => {});
                  reject(err);
                });
              }).catch(err => {
                core.warning(`Image download failed: ${err.message}`);
              });

              const repoRelative = `images/${filename}`;
              core.info(`Image saved as ${repoRelative}`);
              ap.image_url = repoRelative;
              return ap;
            }

            // Download image (from JSON image_url or issue body) and update ap.image_url to local path
            await downloadImageIfNeeded(ap, body);

            const filePath = path.join(process.env.GITHUB_WORKSPACE, 'ap_data.json');
            core.info(`Reading ${filePath} for edit...`);

            const raw = fs.readFileSync(filePath, 'utf8');

            let arr;
            try {
              arr = JSON.parse(raw);
            } catch (err) {
              core.setFailed('ap_data.json is not valid JSON: ' + err.message);
              return;
            }

            if (!Array.isArray(arr)) {
              core.setFailed('ap_data.json is not a JSON array.');
              return;
            }

            // Try to find the entry to edit:
            // 1) Prefer matching the "Requested edit for" label (original Vendor + Model)
            // 2) Fallback to matching current ap.vendor + ap.model
            let targetIndex = -1;
            if (requestedLabel) {
              for (let i = 0; i < arr.length; i++) {
                const lbl = normalizeLabel(`${arr[i].vendor} ${arr[i].model}`);
                if (lbl === requestedLabel) {
                  targetIndex = i;
                  break;
                }
              }
            }

            if (targetIndex === -1) {
              const fallbackLabel = normalizeLabel(`${ap.vendor} ${ap.model}`);
              for (let i = 0; i < arr.length; i++) {
                const lbl = normalizeLabel(`${arr[i].vendor} ${arr[i].model}`);
                if (lbl === fallbackLabel) {
                  targetIndex = i;
                  break;
                }
              }
            }

            if (targetIndex === -1) {
              core.setFailed('Could not find an existing AP entry to edit based on vendor/model.');
              return;
            }

            core.info(`Updating existing AP at index ${targetIndex}`);
            arr[targetIndex] = ap;

            const updated = JSON.stringify(arr, null, 2) + '\n';
            fs.writeFileSync(filePath, updated, 'utf8');

            core.exportVariable('AP_VENDOR', ap.vendor);
            core.exportVariable('AP_MODEL', ap.model);
            core.exportVariable('ISSUE_NUMBER', issue.number.toString());

      - name: Create pull request for edited AP
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "Edit AP: ${{ env.AP_VENDOR }} ${{ env.AP_MODEL }}"
          branch: "edit-ap-from-issue-${{ env.ISSUE_NUMBER }}"
          title: "Edit AP from issue #${{ env.ISSUE_NUMBER }}: ${{ env.AP_VENDOR }} ${{ env.AP_MODEL }}"
          body: |
            This PR updates an existing AP entry derived from issue #${{ env.ISSUE_NUMBER }}.

            Vendor: **${{ env.AP_VENDOR }}**
            Model: **${{ env.AP_MODEL }}**

            Please review the changes to `ap_data.json` (and any new image under `images/`) before merging.
          labels: |
            edit-ap


