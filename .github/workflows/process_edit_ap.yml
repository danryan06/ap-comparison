name: Process Edit AP Submissions

on:
  issues:
    types: [opened, edited]

permissions:
  contents: write
  pull-requests: write
  issues: read

jobs:
  edit-ap-from-issue:
    runs-on: ubuntu-latest
    if: >
      github.event.issue.state == 'open' &&
      startsWith(github.event.issue.title, 'Edit AP:')

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Extract JSON from issue body, download image, and update ap_data.json
        id: update-json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const https = require('https');
            const http = require('http');

            // In github-script, context.payload.issue is always available for issue events
            const issue = context.payload.issue;
            
            if (!issue || !issue.body) {
              core.setFailed('Issue data is not available. This should not happen for issue events.');
              return;
            }

            const body = issue.body;
            core.info(`Processing issue #${issue.number}: ${issue.title}`);

            // Find the ```json ... ``` block containing the updated AP entry
            let match = body.match(/```json\s*([\s\S]*?)```/);
            if (!match) {
              // Fallback: try any JSON-looking block
              match = body.match(/\{\s*[\s\S]*\}/);
            }

            if (!match) {
              core.setFailed('No JSON snippet found in issue body. Make sure the JSON snippet field is filled.');
              return;
            }

            const jsonText = match[1] ? match[1].trim() : match[0].trim();
            core.info('Found updated AP JSON snippet:');
            core.info(jsonText);

            let ap;
            try {
              ap = JSON.parse(jsonText);
            } catch (err) {
              core.setFailed('Invalid JSON in issue: ' + err.message);
              return;
            }

            // Basic sanity checks
            if (!ap.vendor || !ap.model) {
              core.setFailed('JSON must include at least "vendor" and "model" fields.');
              return;
            }

            // Helper to slugify vendor/model for filenames
            function slugify(s) {
              return String(s || '')
                .toLowerCase()
                .trim()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
            }

            // Helper to normalize "Vendor Model" strings
            function normalizeLabel(s) {
              return String(s || '')
                .toLowerCase()
                .trim()
                .replace(/\s+/g, ' ');
            }

            // Helper function for flexible AP matching (vendor name variations)
            function matchesAP(entry, vendor, model) {
              const entryVendor = (entry.vendor || '').trim();
              const entryModel = (entry.model || '').trim();
              const vendorLower = (vendor || '').trim().toLowerCase();
              const modelLower = (model || '').trim().toLowerCase();
              const entryVendorLower = entryVendor.toLowerCase();
              const entryModelLower = entryModel.toLowerCase();
              
              // Exact match (case-sensitive)
              if (entryVendor === vendor && entryModel === model) {
                return true;
              }
              
              // Case-insensitive match
              if (entryVendorLower === vendorLower && entryModelLower === modelLower) {
                return true;
              }
              
              // Partial vendor match (e.g., "Extreme" matches "Extreme Networks") and exact model match
              if ((vendorLower.includes(entryVendorLower) || entryVendorLower.includes(vendorLower)) &&
                  entryModelLower === modelLower) {
                return true;
              }
              
              return false;
            }

            // Try to extract the "Requested edit for: Vendor Model" line
            const requestedMatch = body.match(/^Requested edit for:\s*(.+)$/m);
            const requestedLabelRaw = requestedMatch ? requestedMatch[1].trim() : '';
            const requestedLabel = normalizeLabel(requestedLabelRaw);
            core.info(`Requested edit for: ${requestedLabel || '(not specified)'}`);

            // Try to find an image URL from JSON or issue body
            function findImageUrlFromBody(text) {
              if (!text) return null;
              
              // First, try to find markdown image syntax: ![alt](url)
              const markdownImgMatch = text.match(/!\[[^\]]*\]\((https?:\/\/[^\s)]+)\)/i);
              if (markdownImgMatch) {
                return markdownImgMatch[1];
              }
              
              // Match common image hosts and extensions OR GitHub user-images URLs
              const imgRegex = /(https?:\/\/[^\s)]+?(?:\.(?:png|jpe?g|gif|webp)(?:\?[^\s)]*)?|user-images\.githubusercontent\.com\/[^\s)]+))/i;
              const m = text.match(imgRegex);
              return m ? m[1] : null;
            }

            async function downloadImageIfNeeded(ap, bodyText) {
              let url = ap.image_url && String(ap.image_url).trim();
              core.info(`Checking for image URL in JSON: ${url || '(not found)'}`);
              
              if (!url) {
                url = findImageUrlFromBody(bodyText);
                core.info(`Checking for image URL in issue body: ${url || '(not found)'}`);
              }
              
              if (!url) {
                core.info('No image URL found in JSON or issue body; skipping image download.');
                return ap;
              }

              core.info(`Attempting to download image from ${url}`);

              const imagesDir = path.join(process.env.GITHUB_WORKSPACE, 'images');
              fs.mkdirSync(imagesDir, { recursive: true });

              const vendorSlug = slugify(ap.vendor);
              const modelSlug = slugify(ap.model);

              // Create manufacturer subfolder
              const vendorDir = path.join(imagesDir, vendorSlug);
              fs.mkdirSync(vendorDir, { recursive: true });

              const extMatch = url.match(/\.(png|jpe?g|gif|webp)(?:\?|#|$)/i);
              const ext = extMatch ? `.${extMatch[1].toLowerCase().replace('jpeg','jpg')}` : '.jpg';
              const filename = `${vendorSlug}-${modelSlug}${ext}`;
              const destPath = path.join(vendorDir, filename);

              const client = url.startsWith('https:') ? https : http;

              try {
                await new Promise((resolve, reject) => {
                  const file = fs.createWriteStream(destPath);
                  const request = client.get(url, response => {
                    if (response.statusCode && response.statusCode >= 400) {
                      file.close();
                      fs.unlink(destPath, () => {});
                      return reject(new Error(`Image download failed with status ${response.statusCode}`));
                    }
                    response.pipe(file);
                    file.on('finish', () => {
                      file.close();
                      resolve(null);
                    });
                  });
                  request.on('error', err => {
                    file.close();
                    fs.unlink(destPath, () => {});
                    reject(err);
                  });
                  request.setTimeout(30000, () => {
                    request.destroy();
                    reject(new Error('Image download timeout'));
                  });
                });

                const repoRelative = `images/${vendorSlug}/${filename}`;
                core.info(`Image saved as ${repoRelative}`);
                ap.image_url = repoRelative;
              } catch (err) {
                core.warning(`Image download failed: ${err.message}. Continuing without image update.`);
              }

              return ap;
            }

            // Download image (from JSON image_url or issue body) and update ap.image_url to local path
            await downloadImageIfNeeded(ap, body);

            const filePath = path.join(process.env.GITHUB_WORKSPACE, 'ap_data.json');
            core.info(`Reading ${filePath} for edit...`);

            const raw = fs.readFileSync(filePath, 'utf8');

            let arr;
            try {
              arr = JSON.parse(raw);
            } catch (err) {
              core.setFailed('ap_data.json is not valid JSON: ' + err.message);
              return;
            }

            if (!Array.isArray(arr)) {
              core.setFailed('ap_data.json is not a JSON array.');
              return;
            }

            // Try to find the entry to edit with flexible matching:
            // 1) Prefer matching the "Requested edit for" label (original Vendor + Model)
            // 2) Fallback to matching current ap.vendor + ap.model with flexible vendor matching
            let targetIndex = -1;
            
            if (requestedLabel) {
              // Parse requested label to get vendor and model
              const requestedParts = requestedLabel.split(' ');
              if (requestedParts.length >= 2) {
                const requestedVendor = requestedParts.slice(0, -1).join(' ');
                const requestedModel = requestedParts[requestedParts.length - 1];
                
                for (let i = 0; i < arr.length; i++) {
                  if (matchesAP(arr[i], requestedVendor, requestedModel)) {
                    targetIndex = i;
                    core.info(`Found entry by requested label at index ${i} (${arr[i].vendor} ${arr[i].model})`);
                    break;
                  }
                }
              }
            }

            if (targetIndex === -1) {
              // Use flexible matching for vendor/model
              for (let i = 0; i < arr.length; i++) {
                if (matchesAP(arr[i], ap.vendor, ap.model)) {
                  targetIndex = i;
                  core.info(`Found entry by vendor/model at index ${i} (${arr[i].vendor} ${arr[i].model})`);
                  break;
                }
              }
            }

            if (targetIndex === -1) {
              // Provide helpful error with similar entries
              const similar = arr.filter(x => 
                (x.model || '').trim().toLowerCase() === (ap.model || '').trim().toLowerCase()
              );
              let errorMsg = `Could not find an existing AP entry to edit. Looking for: "${ap.vendor} ${ap.model}"`;
              if (similar.length > 0) {
                errorMsg += `\nFound ${similar.length} AP(s) with model "${ap.model}":`;
                similar.forEach(x => {
                  errorMsg += `\n  - ${x.vendor} ${x.model}`;
                });
              }
              core.setFailed(errorMsg);
              return;
            }

            // Preserve existing image_url if the new entry doesn't have one or has an empty string
            const existingEntry = arr[targetIndex];
            const newImageUrl = ap.image_url && String(ap.image_url).trim();
            if (!newImageUrl && existingEntry.image_url && String(existingEntry.image_url).trim()) {
              core.info(`Preserving existing image_url: ${existingEntry.image_url}`);
              ap.image_url = existingEntry.image_url;
            }

            core.info(`Updating existing AP at index ${targetIndex}`);
            arr[targetIndex] = ap;

            const updated = JSON.stringify(arr, null, 2) + '\n';
            fs.writeFileSync(filePath, updated, 'utf8');
            core.info('Successfully updated ap_data.json');

            // Set outputs instead of environment variables
            core.setOutput('vendor', ap.vendor);
            core.setOutput('model', ap.model);
            core.setOutput('issue_number', issue.number.toString());

      - name: Create pull request for edited AP
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "Edit AP: ${{ steps.update-json.outputs.vendor }} ${{ steps.update-json.outputs.model }}"
          branch: "edit-ap-from-issue-${{ steps.update-json.outputs.issue_number }}"
          title: "Edit AP from issue #${{ steps.update-json.outputs.issue_number }}: ${{ steps.update-json.outputs.vendor }} ${{ steps.update-json.outputs.model }}"
          body: |
            This PR updates an existing AP entry derived from issue #${{ steps.update-json.outputs.issue_number }}.

            Vendor: **${{ steps.update-json.outputs.vendor }}**
            Model: **${{ steps.update-json.outputs.model }}**

            Please review the changes to `ap_data.json` (and any new image under `images/`) before merging.
          labels: |
            edit-ap
